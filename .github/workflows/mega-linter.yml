---
# MegaLinter GitHub Action configuration file
# More info at https://megalinter.io
name: MegaLinter

permissions:
  checks: write
  pull-requests: write
  contents: write

on: # yamllint disable-line rule:truthy
  # Trigger mega-linter at every push. Action will also be visible from Pull Requests to main
  push: # Comment this line to trigger action only on pull-requests (not recommended if you don't pay for GH Actions)
  pull_request:
    branches: [master, main]

env: # Comment env block if you do not want to apply fixes
  # Apply linter fixes configuration
  APPLY_FIXES: all # When active, APPLY_FIXES must also be defined as environment variable (in github/workflows/mega-linter.yml or other CI tool)
  APPLY_FIXES_EVENT: push # Decide which event triggers application of fixes in a commit or a PR (pull_request, push, all)
  # I tried around a lot to make the test workflow run on pull_request events,
  # but it it only worked when creating a new PR. By default, this would target the branch of the PR
  # and not the main branch. Instead of trying around to cherry-pick the commits from the PR
  # etc. I decided to just run the workflow on push events to the main branch and then create
  # a PR targeting the main branch.
  APPLY_FIXES_MODE: pull_request # If APPLY_FIXES is used, defines if the fixes are directly committed (commit) or posted in a PR (pull_request)

concurrency:
  group: ${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  build:
    name: MegaLinter
    runs-on: ubuntu-latest
    permissions:
      # Give the default GITHUB_TOKEN write permission to commit and push, comment issues & post new PR
      # Remove the ones you do not need
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Create alpine-wheels folder
        run: mkdir alpine-wheels

      - name: Cache wheel directory
        id: cache-wheels
        uses: actions/cache@v3
        with:
          path: ${{ github.workspace }}/alpine-wheels
          key: ${{ runner.os }}-alpine-wheels-${{ hashFiles('requirements-dev.txt') }}
          restore-keys: |
            ${{ runner.os }}-alpine-wheels-${{ hashFiles('requirements-dev.txt') }}

      - name: Set up Alpine Linux
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        uses: jirutka/setup-alpine@v1
        with: # cfitsio, py3-pkgconfig, curl-dev, and zlib for healpy
          packages: >
            build-base
            python3-dev
            py3-pip
            gfortran
            fftw-dev
            git
            openblas-dev
            cmake
            geos-dev
            cfitsio
            py3-pkgconfig
            curl-dev
            zlib-dev

      - name: List workspace
        run: ls -l .

      - name: Upgrade pip and install requirements for building
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          python -m pip install --upgrade pip
          python -m pip install meson-python meson ninja wheel build
        shell: alpine.sh {0}

      - name: Remove version settings
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          sed 's/==.*//' requirements-dev.txt > requirements-dev_no_version.txt
        shell: alpine.sh {0}

      - name: Remove torch entry (unsupported by alpine)
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          sed -i '/^torch/d' requirements-dev_no_version.txt
        shell: alpine.sh {0}

      - name: Run CMake to find LAPACK
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          echo "find_package(LAPACK)" > CMakeLists.txt
          echo "if(LAPACK_FOUND)" >> CMakeLists.txt
          echo '  message("LAPACK found")' >> CMakeLists.txt
          echo '  message("LAPACK include dirs: ${LAPACK_INCLUDE_DIRS}")' >> CMakeLists.txt
          echo '  message("LAPACK libraries: ${LAPACK_LIBRARIES}")' >> CMakeLists.txt
          echo "else()" >> CMakeLists.txt
          echo '  message(FATAL_ERROR "LAPACK not found")' >> CMakeLists.txt
          echo "endif()" >> CMakeLists.txt
          cmake .
        shell: alpine.sh {0}

      - name: Run pkg-config to find LAPACK
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          pkg-config --libs --cflags lapack || true
        shell: alpine.sh {0}

      - name: Build wheel for pyshtools
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          git clone https://github.com/FlorianPfaff/SHTOOLS.git
          cd SHTOOLS
          git checkout meson
          python -m build
          cd ..
          mv SHTOOLS/dist/*.whl ./alpine-wheels/
          rm -rf SHTOOLS
        shell: alpine.sh {0}

      - name: Install required packages and dependencies
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: python -m pip install --find-links=./alpine-wheels -r requirements-dev_no_version.txt
        shell: alpine.sh {0}

      - name: Print requirements-dev_no_version.txt
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: cat requirements-dev_no_version.txt
        shell: alpine.sh {0}

      - name: Freeze requirements
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: python -m pip freeze > requirements-tmp.txt
        shell: alpine.sh {0}

      - name: Download compatible packages
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          python -m pip download --find-links=./alpine-wheels -r requirements-tmp.txt -d ./alpine-wheels
        shell: alpine.sh {0}

      - name: Build wheels
        if: steps.cache-wheels.outputs.cache-hit != 'true'
        run: |
          cd ./alpine-wheels
          for src in *.tar.gz; do
            python -m pip wheel "$src" --no-deps --wheel-dir=./
            rm "$src"
          done
          cd ..
        shell: alpine.sh {0}

      - name: List available wheels
        run: ls -l ./alpine-wheels

      - name: Clean up temporary files (in case they are generated)
        run: rm -rf myenv CMakeFiles CMakeCache.txt cmake_install.cmake Makefile

    